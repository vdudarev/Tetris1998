                            2.1. МЕТОД  РЕШЕНИЯ.

   Пусть игровой стакан представлен как двумерный массив A логических величин с
размерностью [-2..15, 1..22]. (Размерность игрового стакана - [1..12, 1..19]).
Причем A[i,j] = ИСТИНА, если элемент стакана [i,j] заполнен частью какой-либо
фигуры, иначе A[i,j] = ЛОЖЬ соответственно. Где i - номер строки и j - номер
столбца.
   Игровые фигуры хранятся в массиве игровых фигур Fig с размерностью [0..16].
Где 15 и 16 элементы являются служебными.
Причем каждая фигура Fig[i] содержит информацию о своем цвете и образе. Данные
об образе содержатся в матрице с размерностью 4x4 состоящей из нулей и единиц.
(Единица в случае, если элемент матрицы [i,j] содержит часть фигуры).

Генерируем номер текущей фигуры (от 0 до NumFig).
Пусть логическая переменная EndOfGame = ЛОЖЬ и массив стакана A пуст.

Пока EndOfGame = ЛОЖЬ повторяем следующие действия:
1. Случайно генерируем номер следующей фигуры (Next) от 0 до NumFig (где NumFig
   - число фигур в массиве, которое не превышает 14) и показываем ее в окне
   просмотра следующей фигуры.
2. Пытаемся поместить текущую фигуру в массив A по координатам (5,1) без нало-
   жения на другие фигуры в стакане. Если это не удается, то положим
   EndOfGame = ИСТИНА, иначе проделываем следующее:
   a) отображаем текущую фигуру на экране и помещаем ее в массив A по
      координатам (5,1);
   b) положим NextFig = ЛОЖЬ и Drop = ЛОЖЬ;
   c) продвижение фигуры вниз (см. ниже);
   d) анализируем не заполнились ли какие-либо горизонтальные линии в стакане,
      просматривая массив A. Если да, то удаляем соответствующие строки из
      массива A и с экрана, перемещая на их место верхние строки и отображаем
      новую информацию об очках, линиях (и может быть уровне, если следует его
      повесить).
   e) переменной Cur присваиваем значение Next;

   Детализация пункта 2.c (продвижение фигуры вниз):
Пока NextFig = ЛОЖЬ выполняем следующие действия:
I. Возьмем показание времени с таймера.
II.Пока не настало время переместить фигуру на 1 шаг вниз и Drop = ЛОЖЬ и
      EndOfGame = ЛОЖЬ делаем следующее:
   1. Если нажата клавиша, то анализируем ее код и выполняем одно из следую-
      щих действий:
         ВЛЕВО, ВПРАВО:
            a) "Вырезаем" фигуру из массива A;
            b) Пытаемся поместить фигуру по координатам (X-1,Y) - ВЛЕВО или
               (X+1,Y) - ВПРАВО. Если это удалось, то изменяется на 1 коорди-
               ната X, "O'k";    иначе "возвращаем" фигуру.
         ПЕРЕВОРОТ:
            a) "Вырезаем" фигуру из массива A;
            b) Пытаемся поместить перевернутый образ фигуры по координатам
               (X,Y). Если это удалось, то "O'k" для нового образа;   иначе
               "возвращаем" фигуру.
         БРОСОК: Положим Drop = ИСТИНА.
   2. "Вырезаем" фигуру.
   3. "Пытаемся поместить" фигуру по координатам (X, Y+1). Если это удается, то
      положим Y:=Y+1 и "O'k" иначе "возвращаем" фигуру и NextFig:=ИСТИНА.
   4. Если ((NextFig) И Drop) ИЛИ (НЕ Drop) = ИСТИНА то вернуться на пункт 4.
III. Анализируем текущее состояние массива A.

Ограничения:
   NumFig >= 0.

Примечания:
   1. "Вырезаем" фигуру из массива A означает то, что мы объявляем места в A,
      ранее занятые этой фигурой, свободными.
   2. "Пытаемся поместить" фигуру означает то, что осуществляется попытка по-
      местить образ фигуры по соответствующим координатам без наложения на
      уже находящиеся фигуры и без выхода за границы стакана.
   3. "Возвращаем" фигуру означает то, что мы объявляем места в A, ранее
      освобожденные "вырезанием" фигуры вновь занятыми.
   4. "O'k" = фигура стирается на прежнем месте и рисуется на новом c добавле-
      нием ее образа в A по новым координатам.
